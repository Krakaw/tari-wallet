<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="icon.png">
    <title>Tari Wallet Scanner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            padding: 30px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .left-panel,
        .right-panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
        }

        .section {
            margin-bottom: 25px;
        }

        .section h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.3em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #34495e;
        }

        input,
        select,
        textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: #3498db;
        }

        textarea {
            resize: vertical;
            min-height: 80px;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-success {
            background: linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .btn-info {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .logs {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
        }

        .log-entry {
            margin-bottom: 5px;
            display: flex;
            align-items: flex-start;
        }

        .log-time {
            color: #95a5a6;
            margin-right: 10px;
            min-width: 80px;
        }

        .log-level {
            margin-right: 10px;
            font-weight: bold;
            min-width: 20px;
        }

        .log-level.info {
            color: #3498db;
        }

        .log-level.success {
            color: #2ecc71;
        }

        .log-level.error {
            color: #e74c3c;
        }

        .log-level.warning {
            color: #f39c12;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            width: 0%;
            transition: width 0.3s ease;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .result-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #3498db;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .result-card:has(#currentBalanceT) {
            grid-column: 1 / -1;
        }

        .result-card h4 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .result-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #3498db;
        }

        .hidden {
            display: none;
        }

        .trace-log {
            display: none;
        }

        .log-controls {
            margin-bottom: 15px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #2c3e50;
            transition: color 0.2s ease;
            user-select: none;
        }

        .checkbox-label:hover {
            color: #3498db;
        }

        /* Custom checkbox styling */
        .custom-checkbox {
            position: relative;
            width: 20px;
            height: 20px;
            margin: 0;
        }

        .custom-checkbox input[type="checkbox"] {
            opacity: 0;
            position: absolute;
            width: 100%;
            height: 100%;
            margin: 0;
            cursor: pointer;
        }

        .checkbox-custom {
            position: absolute;
            top: 0;
            left: 0;
            width: 20px;
            height: 20px;
            border: 2px solid #ddd;
            border-radius: 4px;
            background: white;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .checkbox-custom::after {
            content: '';
            width: 6px;
            height: 10px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg) scale(0);
            transition: transform 0.2s ease;
        }

        .custom-checkbox input[type="checkbox"]:checked + .checkbox-custom {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            border-color: #3498db;
        }

        .custom-checkbox input[type="checkbox"]:checked + .checkbox-custom::after {
            transform: rotate(45deg) scale(1);
        }

        .custom-checkbox input[type="checkbox"]:hover + .checkbox-custom {
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        .custom-checkbox input[type="checkbox"]:focus + .checkbox-custom {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 2em;
            }

            .container {
                margin: 10px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üåü Tari Wallet Scanner</h1>
            <p>Browser-based blockchain scanner for Tari wallets</p>

        </div>

        <div class="main-content">
            <div class="left-panel">
                <div class="section">
                    <h3>üìù Scanner Configuration</h3>
                    <div class="form-group">
                        <label for="scannerData">View Key or Seed Phrase:</label>
                        <textarea id="scannerData"
                            placeholder="Enter your view key or seed phrase here... (automatically detected)"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="baseNodeUrl">Base Node URL:</label>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <input type="text" id="baseNodeUrl" value="https://rpc.tari.com"
                                placeholder="https://rpc.tari.com" style="flex: 1;">
                            <div id="connectionStatus" onclick="checkConnection()"
                                style="cursor: pointer; padding: 8px 12px; border-radius: 6px; font-size: 12px; font-weight: 600; min-width: 100px; text-align: center;"
                                title="Click to refresh connection status">
                                ‚è≥ Checking...
                            </div>
                        </div>
                    </div>
                </div>

                <div class="section">
                    <h3>üîç Scanning Controls</h3>
                    <div class="form-group">
                        <label for="scanMode">Scan Mode:</label>
                        <select id="scanMode">
                            <option value="range">Height Range</option>
                            <option value="specific">Specific Heights</option>
                        </select>
                    </div>
                    <div id="rangeMode">
                        <div class="form-group">
                            <label for="startHeight">Start Height:</label>
                            <input type="number" id="startHeight" value="0" min="0">
                        </div>
                        <div class="form-group">
                            <label for="endHeight">End Height (optional):</label>
                            <input type="number" id="endHeight" placeholder="Leave empty for tip">
                        </div>
                    </div>
                    <div id="specificMode" class="hidden">
                        <div class="form-group">
                            <label for="specificHeights">Block Heights (comma-separated):</label>
                            <textarea id="specificHeights" placeholder="e.g., 100, 200, 300, 1000"></textarea>
                            <p style="font-size: 0.9em; color: #666; margin-top: 5px;">
                                ‚ö° Optimized: Only requested heights are fetched (no pagination or range scanning)
                            </p>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="limit">Limit:</label>
                        <input type="number" id="limit" value="10" min="1" max="1000">
                    </div>
                </div>

               

                <div class="section">
                    <h3>üéõÔ∏è Actions</h3>
                    <button class="btn" onclick="toggleScan()" disabled id="scanToggleBtn">üîç Start Scan</button>
                    <button class="btn btn-warning" onclick="resetScanner()" disabled id="resetScannerBtn">üîÑ Reset
                        Scanner</button>
                </div>

                <div id="statusArea"></div>
            </div>

            <div class="right-panel">
                <div class="section">
                    <h3>üìä Progress</h3>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div id="progressText">Ready to start...</div>
                </div>

                <div class="section">
                    <h3>üìà Results</h3>
                    <div class="results-grid" id="resultsGrid">
                        <div class="result-card">
                            <h4>Current Block Height</h4>
                            <div class="result-value" id="currentBlockHeight">-</div>
                        </div>
                        <div class="result-card">
                            <h4>Blocks Scanned</h4>
                            <div class="result-value" id="blocksScanned">0</div>
                        </div>
                        <div class="result-card">
                            <h4>Data Downloaded</h4>
                            <div class="result-value" id="downloadSize">0 B</div>
                        </div>
                        <div class="result-card">
                            <h4>Total Records</h4>
                            <div class="result-value" id="transactionsFound">0</div>
                        </div>
                        <div class="result-card">
                            <h4>Available Outputs</h4>
                            <div class="result-value" id="unspentCount">0</div>
                        </div>
                        <div class="result-card">
                            <h4>Used Outputs</h4>
                            <div class="result-value" id="spentCount">0</div>
                        </div>
                        <div class="result-card">
                            <h4>Spending Events</h4>
                            <div class="result-value" id="spendingEvents">0</div>
                        </div>
                       
                        
                        <div class="result-card">
                            <h4>Total Value Received (T)</h4>
                            <div class="result-value" id="totalValueReceived">0.000000</div>
                        </div>
                        <div class="result-card">
                            <h4>Total Value Spent (T)</h4>
                            <div class="result-value" id="totalSpentValue">0.000000</div>
                        </div>
                        <div class="result-card">
                            <h4>Current Balance (T)</h4>
                            <div class="result-value" id="currentBalanceT">0.000000</div>
                        </div>
                    </div>
                </div>

                <div class="section">
                    <h3>üìù Console Logs</h3>
                    <div class="log-controls">
                        <label class="checkbox-label">
                            <div class="custom-checkbox">
                                <input type="checkbox" id="showTrace" onchange="toggleTraceLogs()">
                                <span class="checkbox-custom"></span>
                            </div>
                            Show Trace Logs
                        </label>
                    </div>

                    <div class="logs" id="logsContainer"></div>
                </div>

                 <div class="section">
                    <h3>üßπ Memory Management</h3>
                    <div class="form-group">
                        <label for="maxTransactions">Max Transactions to Keep:</label>
                        <input type="number" id="maxTransactions" value="5000" min="1000" max="50000" 
                               title="Limits memory usage by keeping only the most recent transactions. Balance calculations remain accurate.">
                    </div>
                    <p style="font-size: 0.9em; color: #666; margin-top: 10px;">
                        Log entries are automatically limited to 1000 entries. Transaction cleanup happens automatically when the limit is exceeded.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Global state
        let wasm = null;
        let scanner = null;
        let isScanning = false;
        let totalDownloadSize = 0;

        // HttpClient class removed - enhanced scanner handles HTTP communication internally

        window.toggleTraceLogs = function() {
            const showTrace = document.getElementById('showTrace').checked;
            const traceLogs = document.querySelectorAll('.trace-log');
            traceLogs.forEach(log => {
                log.style.display = showTrace ? 'block' : 'none';
            });
        }
        // Logging functions
        function log(level, message, isTrace = false) {
            const container = document.getElementById('logsContainer');
            
            // Create new log entry first
            const entry = document.createElement('div');
            entry.className = `log-entry ${isTrace ? 'trace-log' : ``} ${level}-log`;

            const time = new Date().toLocaleTimeString();
            const levelIcon = {
                'info': '‚ÑπÔ∏è',
                'success': '‚úÖ',
                'error': '‚ùå',
                'warning': '‚ö†Ô∏è',
            }[level] || '‚ÑπÔ∏è';

            entry.innerHTML = `
                <span class="log-time">${time}</span>
                <span class="log-level ${level}">${levelIcon}</span>
                <span>${message}</span>
            `;

            // Add the new entry
            container.appendChild(entry);
            
            // Maintain log limit - smart cleanup that handles hidden trace logs
            const maxLogEntries = 100;
            while (container.children.length > maxLogEntries) {
                // Find the first child to remove (prefer hidden ones first)
                let childToRemove = null;
                
                // First try to remove a hidden trace log
                for (let i = 0; i < container.children.length; i++) {
                    const child = container.children[i];
                    if (child.style.display === 'none' || child.classList.contains('trace-log')) {
                        const computedStyle = window.getComputedStyle(child);
                        if (computedStyle.display === 'none') {
                            childToRemove = child;
                            break;
                        }
                    }
                }
                
                // If no hidden logs found, remove the oldest visible one
                if (!childToRemove) {
                    childToRemove = container.children[0];
                }
                
                container.removeChild(childToRemove);
            }

            container.scrollTop = container.scrollHeight;

            // Also show status for important messages
            if (level === 'error') {
                showStatus(message, level);
            }
        }

        function showStatus(message, type) {
            // Only keep the last n statuses
            const maxStatuses = 10;
            const statuses = document.querySelectorAll('.status');

            if (statuses.length >= maxStatuses) {
                statuses[0].remove();
            }

            const statusArea = document.getElementById('statusArea');
            const status = document.createElement('div');
            status.className = `status ${type}`;
            status.textContent = message;
            statusArea.appendChild(status);

            setTimeout(() => {
                status.remove();
            }, 5000);
        }

        function updateProgress(percentage, text) {
            document.getElementById('progressFill').style.width = `${percentage}%`;
            document.getElementById('progressText').textContent = text;
        }

                function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function updateResults(blocksScanned, stats, currentBlockHeight = null, downloadSize = null) {
            document.getElementById('blocksScanned').textContent = blocksScanned.toLocaleString();
            document.getElementById('transactionsFound').textContent = (stats.total_transactions || 0).toLocaleString();
            document.getElementById('unspentCount').textContent = (stats.total_outputs || 0).toLocaleString();
            document.getElementById('spentCount').textContent = (stats.total_spent || 0).toLocaleString();
            document.getElementById('spendingEvents').textContent = (stats.outbound_transactions || 0).toLocaleString();
            
            const currentBalanceT = ((stats.current_balance || 0) / 1000000);
            document.getElementById('currentBalanceT').textContent = currentBalanceT.toLocaleString(undefined, { minimumFractionDigits: 6, maximumFractionDigits: 6 });
            
            const totalValueReceivedT = ((stats.total_value || 0) / 1000000);
            document.getElementById('totalValueReceived').textContent = totalValueReceivedT.toLocaleString(undefined, { minimumFractionDigits: 6, maximumFractionDigits: 6 });
            
            const totalSpentValueT = ((stats.total_spent_value || 0) / 1000000);
            document.getElementById('totalSpentValue').textContent = totalSpentValueT.toLocaleString(undefined, { minimumFractionDigits: 6, maximumFractionDigits: 6 });
            
            if (currentBlockHeight !== null) {
                document.getElementById('currentBlockHeight').textContent = currentBlockHeight.toLocaleString();
            }
            
            if (downloadSize !== null) {
                document.getElementById('downloadSize').textContent = formatFileSize(downloadSize);
            }
        }

        // WASM Scanner implementation
        window.initializeWasm = async function () {
            try {
                log('info', 'üöÄ Initializing Tari WASM Scanner...');

                // Import the WASM module
                wasm = await import('./lightweight_wallet_libs.js');
                await wasm.default();

                log('success', '‚úÖ WASM module loaded successfully');
                log('info', `üè∑Ô∏è Version: ${wasm.get_version()}`);

                // Enable buttons based on scanner data availability
                updateScanButtonState();
                document.getElementById('resetScannerBtn').disabled = false;

            } catch (error) {
                log('error', `‚ùå Failed to initialize WASM module: ${error.message}`);
                log('info', 'üí° Make sure the WASM package is built for web target:');
                log('info', '   wasm-pack build --target web --out-dir pkg --example wasm_scanner');
            }
        };

        // Update connection status indicator
        function updateConnectionStatus(status, message = '') {
            const statusElement = document.getElementById('connectionStatus');

            switch (status) {
                case 'checking':
                    statusElement.style.background = '#f39c12';
                    statusElement.style.color = 'white';
                    statusElement.textContent = '‚è≥ Checking...';
                    break;
                case 'connected':
                    statusElement.style.background = '#2ecc71';
                    statusElement.style.color = 'white';
                    statusElement.textContent = '‚úÖ Connected';
                    break;
                case 'error':
                    statusElement.style.background = '#e74c3c';
                    statusElement.style.color = 'white';
                    statusElement.textContent = '‚ùå Failed';
                    break;
                case 'disconnected':
                    statusElement.style.background = '#95a5a6';
                    statusElement.style.color = 'white';
                    statusElement.textContent = '‚ö´ Offline';
                    break;
            }

            if (message) {
                statusElement.title = message;
            }
        }

        // Check connection status - simplified since enhanced scanner handles connection internally
        window.checkConnection = async function () {
            const baseNodeUrl = document.getElementById('baseNodeUrl').value.trim();

            if (!baseNodeUrl) {
                updateConnectionStatus('disconnected', 'No URL provided');
                return;
            }

            updateConnectionStatus('checking');
            log('info', 'üì° Testing base node connection...');

            try {
                log('info', `üîó Will connect to ${baseNodeUrl} when scanner is initialized...`);
                
                // Simple fetch test to check if URL is reachable
                const response = await fetch(`${baseNodeUrl}/get_tip_info`, {
                    method: 'GET',
                    headers: { 'Accept': 'application/json' }
                });

                if (response.ok) {
                    updateConnectionStatus('connected', `${baseNodeUrl} is reachable`);
                    log('success', '‚úÖ Base node URL is reachable');
                } else {
                    updateConnectionStatus('error', `HTTP ${response.status}`);
                    log('error', `‚ùå Base node returned HTTP ${response.status}`);
                }

            } catch (error) {
                updateConnectionStatus('error', `Failed to connect: ${error.message}`);
                log('error', `‚ùå Failed to connect to base node: ${error.message}`);
                log('info', `   Make sure the Tari base node is running on ${baseNodeUrl}`);
            }
        };

        // Helper function to update the scan toggle button
        function updateScanButton(isScanning) {
            const button = document.getElementById('scanToggleBtn');
            if (isScanning) {
                button.textContent = '‚èπÔ∏è Stop Scan';
                button.className = 'btn btn-warning';
                button.onclick = stopScan;
            } else {
                button.textContent = 'üîç Start Scan';
                button.className = 'btn';
                button.onclick = startScan;
            }

            // Update button state based on current conditions
            updateScanButtonState();
        }

        // Toggle function for the scan button
        window.toggleScan = function () {
            if (isScanning) {
                stopScan();
            } else {
                startScan();
            }
        };



                async function createScanner() {
            const scannerData = document.getElementById('scannerData').value.trim();

            if (!scannerData) {
                throw new Error('Scanner data is required - please enter a view key or seed phrase');
            }

            log('info', `üîß Creating enhanced scanner (auto-detecting type)...`);
            
            // Provide hints about the data format
            if (scannerData.length === 64 && /^[0-9a-fA-F]+$/.test(scannerData)) {
                log('info', `   Detected possible view key format (64 hex characters)`);
            } else if (scannerData.split(' ').length >= 12 && scannerData.split(' ').length <= 24) {
                log('info', `   Detected possible seed phrase format (${scannerData.split(' ').length} words)`);
            } else {
                log('warning', `   Format unclear - will attempt auto-detection`);
            }

            try {
                scanner = wasm.create_enhanced_wasm_scanner(scannerData);
                log('success', '‚úÖ Enhanced scanner created successfully');
            } catch (error) {
                // Re-throw with more context
                throw new Error(`Scanner creation failed: ${error.message || error}. Please verify your input format.`);
            }

            // Initialize the scanner with base node URL
            const baseNodeUrl = document.getElementById('baseNodeUrl').value.trim();
            if (!baseNodeUrl) {
                throw new Error('Base node URL is required');
            }
            
            log('info', `üåê Initializing scanner with ${baseNodeUrl}...`);
            
            try {
                await scanner.initialize_scanner(baseNodeUrl);
                log('success', '‚úÖ Scanner initialized with base node connection');
            } catch (error) {
                throw new Error(`Failed to initialize scanner with base node: ${error.message || error}`);
            }

            return scanner;
        }

        // Functions removed - enhanced scanner handles block processing internally

        window.stopScan = function () {
            if (!isScanning) {
                log('warning', '‚ö†Ô∏è No scan in progress');
                return;
            }

            log('info', '‚èπÔ∏è Stopping scan...');
            
            // Cancel the enhanced scanner
            if (scanner && scanner.cancel_scan) {
                try {
                    scanner.cancel_scan();
                    log('info', 'üì° Cancellation signal sent to enhanced scanner');
                    
                    // Verify cancellation worked
                    if (scanner.is_cancelled && scanner.is_cancelled()) {
                        log('success', '‚úÖ Scanner confirmed as cancelled');
                    } else {
                        log('warning', '‚ö†Ô∏è Scanner may not be cancelled yet');
                    }
                } catch (error) {
                    log('error', `‚ùå Failed to cancel scanner: ${error.message || error}`);
                }
            } else {
                log('warning', '‚ö†Ô∏è Scanner cancellation method not available');
            }
            
            isScanning = false;
            updateProgress(0, 'Scan stopped by user');

            // Update button state
            updateScanButton(false);
        };

        // fetchSpecificBlocksBatches removed - enhanced scanner handles this internally

        window.startScan = async function () {
            if (!wasm) {
                log('error', '‚ùå WASM not initialized');
                return;
            }

            if (isScanning) {
                log('warning', '‚ö†Ô∏è Scan already in progress');
                return;
            }

            const scannerData = document.getElementById('scannerData').value.trim();
            if (!scannerData) {
                log('error', '‚ùå Scanner data required - please enter a view key or seed phrase');
                return;
            }

            try {
                isScanning = true;
                
                // Reset download size counter
                totalDownloadSize = 0;
                
                // Update button state
                updateScanButton(true);
                
                // Create and initialize scanner
                try {
                    await createScanner();
                } catch (error) {
                    log('error', `‚ùå Failed to create scanner: ${error.message || error}`);
                    log('info', 'üí° Please check that your input is either:');
                    log('info', '   ‚Ä¢ A valid 64-character hexadecimal view key, or');
                    log('info', '   ‚Ä¢ A valid BIP39 seed phrase (12-24 words)');
                    updateProgress(0, 'Scanner creation failed');
                    
                    // Cleanup and exit early
                    isScanning = false;
                    updateScanButton(false);
                    if (scanner && scanner.cleanup_scan) {
                        try { scanner.cleanup_scan(); } catch (e) { /* ignore */ }
                    }
                    return;
                }

                const scanMode = document.getElementById('scanMode').value;
                const limit = parseInt(document.getElementById('limit').value);

                log('info', `üîß Scan mode: ${scanMode}, batch limit: ${limit}`);

                // Configure the enhanced scanner based on scan mode
                if (scanMode === 'specific') {
                    // Parse specific heights
                    const specificHeightsText = document.getElementById('specificHeights').value.trim();
                    if (!specificHeightsText) {
                        log('error', '‚ùå Please enter comma-separated block heights');
                        return;
                    }

                    const heights = specificHeightsText
                        .split(',')
                        .map(h => parseInt(h.trim()))
                        .filter(h => !isNaN(h) && h >= 0)
                        .sort((a, b) => a - b);

                    if (heights.length === 0) {
                        log('error', '‚ùå No valid block heights found');
                        return;
                    }

                    log('info', `üîç Configuring scan for ${heights.length} specific blocks: ${heights.join(', ')}`);
                    log('info', `‚ö° This should use optimized direct fetching (no pagination)`);
                    try {
                        scanner.configure_scan_blocks(JSON.stringify(heights), limit);
                        log('success', '‚úÖ Specific blocks configuration sent to scanner');
                    } catch (error) {
                        log('error', `‚ùå Failed to configure specific blocks: ${error.message || error}`);
                        return;
                    }

                } else {
                    // Range mode
                    const startHeight = parseInt(document.getElementById('startHeight').value);
                    let endHeight = document.getElementById('endHeight').value;

                    // If no end height specified, we'll let the scanner determine the tip
                    if (!endHeight) {
                        endHeight = null;
                    } else {
                        endHeight = parseInt(endHeight);
                    }

                    log('info', `üîç Configuring scan for height range ${startHeight} to ${endHeight || 'tip'}`);
                    log('info', `üìä This will use range scanning with pagination`);
                    try {
                        scanner.configure_scan(BigInt(startHeight), endHeight ? BigInt(endHeight) : null, limit);
                        log('success', '‚úÖ Range configuration sent to scanner');
                    } catch (error) {
                        log('error', `‚ùå Failed to configure range: ${error.message || error}`);
                        return;
                    }
                }

                // Create progress callback
                const progressCallback = (progressInfo) => {
                    if (!isScanning) {
                        log('info', '‚èπÔ∏è Progress callback detected scan was stopped, ending updates');
                        return; // Don't update if scan was stopped
                    }

                    // Check if scanner is cancelled
                    if (scanner && scanner.is_cancelled && scanner.is_cancelled()) {
                        log('info', '‚èπÔ∏è Progress callback detected scanner cancellation');
                        isScanning = false;
                        updateProgress(0, 'Scan cancelled');
                        updateScanButton(false);
                        return;
                    }

                    // Update progress bar
                    updateProgress(progressInfo.progress_percent, 
                        `Block ${progressInfo.current_block} (${progressInfo.blocks_processed}/${progressInfo.total_blocks})`);

                    // Update stats
                    updateResults(
                        progressInfo.blocks_processed, 
                        {
                            total_outputs: progressInfo.outputs_found,
                            total_spent: progressInfo.inputs_found,
                            total_value: 0, // Will be updated from final results
                            total_spent_value: 0,
                            current_balance: 0,
                            total_transactions: progressInfo.outputs_found + progressInfo.inputs_found,
                            inbound_transactions: progressInfo.outputs_found,
                            outbound_transactions: progressInfo.inputs_found
                        },
                        progressInfo.current_block,
                        totalDownloadSize
                    );

                    // Log progress occasionally
                    if (progressInfo.blocks_processed % 50 === 0 || progressInfo.outputs_found > 0) {
                        log('info', `üìä Progress: ${progressInfo.progress_percent.toFixed(1)}% - Block ${progressInfo.current_block} - Found ${progressInfo.outputs_found} outputs`, true);
                    }
                };

                // Create cancellation token
                scanner.create_cancellation_token();
                
                log('info', 'üöÄ Starting enhanced scanner...');
                updateProgress(0, 'Starting enhanced scan...');

                // Perform the scan using enhanced scanner
                const scanResult = await scanner.scan_wallet(progressCallback);

                // Process final results
                if (scanResult.completed) {
                    log('success', 'üìà SCAN COMPLETED SUCCESSFULLY');
                    log('info', `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
                    log('info', `Transactions found: ${scanResult.transaction_count.toLocaleString()}`);
                    log('info', `Total received: ${(scanResult.total_received / 1000000).toLocaleString(undefined, { minimumFractionDigits: 6, maximumFractionDigits: 6 })} T`);
                    log('info', `Total spent: ${(scanResult.total_spent / 1000000).toLocaleString(undefined, { minimumFractionDigits: 6, maximumFractionDigits: 6 })} T`);
                    log('info', `Current balance: ${(scanResult.current_balance / 1000000).toLocaleString(undefined, { minimumFractionDigits: 6, maximumFractionDigits: 6 })} T`);
                    log('info', `Scan duration: ${scanResult.duration_seconds.toFixed(2)} seconds`);
                    
                    updateProgress(100, 'Scan completed successfully!');
                    
                    // Update final results
                    updateResults(
                        0, // blocks_processed - not directly available from scanResult
                        {
                            total_outputs: scanResult.unspent_count,
                            total_spent: scanResult.spent_count,
                            total_value: scanResult.total_received,
                            total_spent_value: scanResult.total_spent,
                            current_balance: scanResult.current_balance,
                            total_transactions: scanResult.transaction_count,
                            inbound_transactions: scanResult.unspent_count,
                            outbound_transactions: scanResult.spent_count
                        },
                        null,
                        totalDownloadSize
                    );

                } else if (scanResult.interrupted) {
                    log('info', 'üìà SCAN INTERRUPTED');
                    log('info', `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
                    log('info', `Partial results - Transactions found: ${scanResult.transaction_count.toLocaleString()}`);
                    log('info', `Current balance: ${(scanResult.current_balance / 1000000).toLocaleString(undefined, { minimumFractionDigits: 6, maximumFractionDigits: 6 })} T`);
                    log('info', `Scan duration: ${scanResult.duration_seconds.toFixed(2)} seconds`);
                    
                    updateProgress(0, 'Scan was interrupted');
                    
                } else if (scanResult.error) {
                    log('error', `‚ùå Scan failed: ${scanResult.error}`);
                    updateProgress(0, 'Scan failed');
                }

            } catch (error) {
                log('error', `‚ùå Scan failed: ${error.message || error}`);
                updateProgress(0, 'Scan failed');
            } finally {
                isScanning = false;
                updateScanButton(false);
                
                // Cleanup scan ID when scan ends (success or failure)
                if (scanner && scanner.cleanup_scan) {
                    try {
                        scanner.cleanup_scan();
                        log('info', 'üßπ Scanner resources cleaned up');
                    } catch (error) {
                        // Ignore cleanup errors
                        log('warning', `‚ö†Ô∏è Failed to cleanup scan resources: ${error.message || error}`);
                    }
                }
            }
        };

        window.resetScanner = function () {
            if (!wasm) {
                log('error', '‚ùå WASM not initialized');
                return;
            }

            try {
                log('info', 'üîÑ Resetting scanner state...');
                
                // Enhanced scanner doesn't have a reset method, so we'll clear the scanner instance
                // It will be recreated on next scan
                scanner = null;
                
                log('success', '‚úÖ Scanner cleared - will be recreated on next scan');

                // Reset UI
                totalDownloadSize = 0;
                const emptyStats = {
                    total_outputs: 0,
                    total_spent: 0,
                    total_value: 0,
                    total_spent_value: 0,
                    current_balance: 0,
                    total_transactions: 0,
                    inbound_transactions: 0,
                    outbound_transactions: 0
                };
                updateResults(0, emptyStats, null, 0);
                document.getElementById('currentBlockHeight').textContent = '-';
                updateProgress(0, 'Ready to start...');

            } catch (error) {
                log('error', `‚ùå Failed to reset scanner: ${error.message}`);
            }
        };


        // Update scan button state based on scanner data availability
        function updateScanButtonState() {
            const scannerData = document.getElementById('scannerData').value.trim();
            const scanToggleBtn = document.getElementById('scanToggleBtn');

            if (!wasm) {
                // WASM not loaded yet
                scanToggleBtn.disabled = true;
                scanToggleBtn.title = 'WASM module not loaded yet';
            } else if (!scannerData) {
                // No scanner data
                scanToggleBtn.disabled = true;
                scanToggleBtn.title = 'Enter a view key or seed phrase to enable scanning';
            } else if (isScanning) {
                // Currently scanning
                scanToggleBtn.disabled = false;
                scanToggleBtn.title = 'Click to stop the current scan';
            } else {
                // Ready to scan
                scanToggleBtn.disabled = false;
                scanToggleBtn.title = 'Click to start scanning with the provided data';
            }
        }

        // Local storage functions
        function saveToLocalStorage(key, value) {
            try {
                localStorage.setItem(`tariScanner_${key}`, value);
            } catch (error) {
                // Silently ignore localStorage errors
            }
        }

        function loadFromLocalStorage(key, defaultValue = '') {
            try {
                return localStorage.getItem(`tariScanner_${key}`) || defaultValue;
            } catch (error) {
                // Silently ignore localStorage errors
                return defaultValue;
            }
        }

        function loadSavedValues() {
            // Load all saved values except scannerData
            const fieldsToLoad = ['scannerData', 'baseNodeUrl', 'startHeight', 'endHeight', 'limit', 'scanMode', 'specificHeights', 'maxTransactions'];

            fieldsToLoad.forEach(fieldId => {
                const element = document.getElementById(fieldId);
                if (element) {
                    const savedValue = loadFromLocalStorage(fieldId);
                    if (savedValue) {
                        element.value = savedValue;
                    }
                }
            });

            // Handle scan mode change after loading
            toggleScanMode();
        }

        function setupInputSaving() {
            // Fields to save (excluding scannerData)
            const fieldsToSave = ['scannerData', 'baseNodeUrl', 'startHeight', 'endHeight', 'limit', 'scanMode', 'specificHeights', 'maxTransactions'];

            fieldsToSave.forEach(fieldId => {
                const element = document.getElementById(fieldId);
                if (element) {
                    const saveValue = () => {
                        saveToLocalStorage(fieldId, element.value);
                    };

                    // Save on input change
                    element.addEventListener('input', saveValue);
                    element.addEventListener('change', saveValue);
                }
            });
        }

        function toggleScanMode() {
            const scanMode = document.getElementById('scanMode').value;
            const rangeMode = document.getElementById('rangeMode');
            const specificMode = document.getElementById('specificMode');

            if (scanMode === 'specific') {
                rangeMode.classList.add('hidden');
                specificMode.classList.remove('hidden');
            } else {
                rangeMode.classList.remove('hidden');
                specificMode.classList.add('hidden');
            }
        }

        // Setup event listeners and initialization
        function setupEventListeners() {
            const baseNodeUrlInput = document.getElementById('baseNodeUrl');
            const scannerDataInput = document.getElementById('scannerData');
            const scanModeSelect = document.getElementById('scanMode');

            // Setup scan mode toggle
            scanModeSelect.addEventListener('change', toggleScanMode);

            // Check connection when URL changes (with debounce)
            let urlChangeTimeout;
            baseNodeUrlInput.addEventListener('input', () => {
                clearTimeout(urlChangeTimeout);
                updateConnectionStatus('disconnected', 'URL changed - click to test');

                // Auto-check after 1 second of no typing
                urlChangeTimeout = setTimeout(() => {
                    if (baseNodeUrlInput.value.trim()) {
                        checkConnection();
                    }
                }, 1000);
            });

            // Also check on Enter key
            baseNodeUrlInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    clearTimeout(urlChangeTimeout);
                    checkConnection();
                }
            });

            // Update scan button state when scanner data changes
            scannerDataInput.addEventListener('input', updateScanButtonState);
            scannerDataInput.addEventListener('paste', () => {
                // Use setTimeout to wait for paste to complete
                setTimeout(updateScanButtonState, 10);
            });

            // Setup input saving for persistent values
            setupInputSaving();
        }

        // Initialize on page load
        log('info', 'üåü Tari Wallet Scanner - Browser loaded');
        loadSavedValues(); // Load saved values from localStorage
        setupEventListeners();
        updateScanButtonState(); // Set initial button state
        initializeWasm();

        // Check initial connection after a short delay
        setTimeout(() => {
            checkConnection();
        }, 500);
    </script>
</body>

</html>